https://www.cnblogs.com/guyun/p/4589115.html

在SQLServer2008中，当设计（修改）表结构之后，再用SQL语句时，列名会显示无效，但执行可以通过。
原因是SQL Server的intellisense（智能感知功能）需要重新整理一下，用快捷键Ctrl+Shift+R即可

web服务控件就是可以在服务器执行的控件，
优势在于可以回传数据（ViewState），带有事件驱动（doPostBack），简化了Html标签的使用，使得开发ASP.net程序可以像开发Winform程序一样简单。
Web服务控件最终还是被渲染（Render）为Html标签。使用WEB服务控件的劣势是会生成一些无用的属性、ViewState等，
不利于SEO，一般在内网系统或者互联网系统的后台中使用WEB服务控件。
如果没有复杂的服务器交互动作，就不用Web服务器控件。runat=server的HTML控件有什么特点：路径不用程序员解析，可以使用“~”来虚拟路径。

REST是一种架构风格，其核心是面向资源；而webService底层SOAP协议，主要核心是面向活动

反射 指程序可以访问、检测和修改它本身状态或行为的一种能力 typeof
程序集包含模块，而模块又包括类型，类型下有成员，反射就是管理程序集，模块，类型的对象，它能够动态的创建类型的实例，
获取或者设置现有对象的类型，能调用类型的方法和访问类型的字段属性。它是在运行时创建和使用类型实例。

优点：
1、反射提高了程序的灵活性和扩展性。
2、降低耦合性，提高自适应能力。
3、它允许程序创建和控制任何类的对象，无需提前硬编码目标类。

缺点：
1、性能问题：使用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码。
   因此反射机制主要应用在对灵活性和拓展性要求很高的系统框架上，普通程序不建议使用。
2、使用反射会模糊程序内部逻辑；程序员希望在源代码中看到程序的逻辑，反射却绕过了源代码的技术，
   因而会带来维护的问题，反射代码比相应的直接代码更复杂。

反射（Reflection）有下列用途：
1、在运行时查看特性（attribute）信息。
2、审查集合中的各种类型，以及实例化这些类型。
3、延迟绑定的方法和属性（property）。
4、在运行时创建新类型，然后使用这些类型执行一些任务。

ViewState
用来保存页面状态
就是说提交之后我们还可以看到文本框里面的内容就是ViewState保存的功劳

ViewState只维护当前页面的状态，不同页面之间不能共享，Session可以

ViewState可以理解为一个隐藏控件

什么时候用抽象类，什么时候用接口
接口用于规范，抽象类用于共性
1、抽象类可以有方法实现，也可以定义非静态的类变量。 接口中只能声明方法，属性，事件，索引器。
2、抽象类是类，只能单继承，接口可以多继承。
3、抽象类可以提供某些方法的具体实现。 接口不可以。
4、抽象类的实例是它的子类给出的。 接口的实例是实现接口的类给出的。
5、在抽象类中加入新的方法，那么它的子类就同时有了这个方法。 接口要重新编写。

堆（Heap）保存值和对象，调用完毕后依然存在，由垃圾回收器查找栈中有无指向该值或对象的引用，没有则从堆中删除。
栈（Stack）由系统管理生存期，存储代码执行和调用路径，执行或调用完毕即从栈中清除。

ref传入时要先初始化 out必须在方法中初始化
使用ref和out时，在方法的参数和执行方法时，都要加ref和out关键字，以满足匹配。
out适用在需要return多个返回值的地方 ref使用在需要被调用的方法修改调用者的引用的时候


泛型：
通过参数化类型，将类型抽象化，实现在同一份代码上操作多种数据类型，达到灵活地复用代码。
好处：
类型安全和减少装箱、拆箱
提高性能、类型安全和质量，减少重复性的编程任务

Server.UrlEncode 按照本地程序设置的编码方式编码
HttpUtility.UrlEncode 默认按照utf-8格式编码

提高.Net性能
1、使用异步方式调用Webf服务和远程对象
2、使用适当的Caching策略来提高性能
3、判断字符串，不用“”
4、页面优化
5、及时关闭数据库连接
6、使用存储过程，并优化查询语句
7、只读数据访问用DataReader, 不要用DataSet

对XML Web Service原理的认识
答： 利用SOAP（简单对象访问协议）在http上执行远程方法调用
     也可以使用WSDL（Web服务描述语言）来完成完整的描述Web服务，
     然后用UDDI注册各个服务提供商提供的服务，以便共享它们


页面生命周期
1、页面初始化
2、实例化控件
3、还原和维护状态
4、运行事件处理程序代码
5、呈现

页面生命周期阶段
1、页请求
   发生在页面生命周期之前，用户请求页时，ASP.NET将确定是否需要分析和编译页，
   从而确定是否开始页面的生命周期，或者是否可以在不运行页面的情况下发送页面缓存以进行响应
2、开始
   设置页属性，如：HttpContext
   在此阶段，页面需要确定是回发请求还是新请求，并设置IsPostBack属性和UICulture属性   
3、页面初始化
   加载所有主题，控件生存，设置UniqueID
4、加载
   如果是回发请求，则为控件加载ViewState和ControlState中的值
5、验证
   调用所有验证程序控件的Validate方法，此方法将设置验证程序控件和页的IsValid属性
6、事件回发处理
   如果是回发请求，则调用所有事件处理程序
7、呈现
   首先对该页和所有控件精细保存视图状态
   然后对每个控件调用Rander方法，它会提供一个文本编译器，用于将控件的输入写入页的Response属性的OutputStream中
8、卸载
   完成呈现，并将页发送到客户端
   准备丢弃该页后，调用卸载，将卸载Response和Request等属性



new
1、实例化对象
2、覆盖基类
3、约束指定泛型类声明中的任何类型参数都必须有公共的无参数构造函数

通过超链接怎样传递中文参数？
答：通过QueryString传递，用UrlEncode编码 用UrlDecode解码。

Server.Transfer和Response.Redirect的区别是什么？

答: Server.Transfer仅是服务器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；
Response.Redirect则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。

Server.Transfer是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器，
浏览器根本不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址。 这个过程中浏览器和Web服务器之间经过了一次交互。

Response.Redirect就是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址，一般来说浏览器会用刚才请求的所有参数重新请求。
这个过程中浏览器和Web服务器之间经过了两次交互。

值类型不能为null, 引用类型可以被赋值null

类不支持多继承, 接口支持多继承

String, Int32, Boolean属于.Net定义的类，string, int, bool相对于C#中对这些类定义的别名。CTS

是否可以从一个static方法内部发出对非static方法的调用？
答：不可以。
因为非static方法是要于对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，
而static方法调用时不需要创建对象，可以直接调用。

内存泄露
指一个不再被程序使用的对象或变量一直被占据在内存中。
长生命周期对象持有短生命周期对象的引用
例如：缓存系统，我们加载一个对象放在缓存中（例如放一个全局Dictionary对象中），然后一直不再使用它，这个对象一直被缓存引用，不能被回收。
扩展：使用弱引用 即使被引用也可以被回收
强引用：Object obj = new Object();
弱引用：WeakReference weakObj = new WeakReference(Object);

一：什么是弱引用

了解弱引用之前，先了解一下什么是强引用
例如 ： Object obj=new Object();
就是一个强引用，内存分配一份空间给用以存储Object数据，这块内存有一个首地址，也就是obj所保存的数据，
内存分配的空间中不仅仅保存着Object对象信息，还保存着自己（Object本身）被引用的次数。

当一个对象被强引用的形式创建的时候，本身被引用的次数已经为1.
接着Object o=obj; 这句代码执行之后，obj指向的Object的存储空间已经被引用了2次，所以Object保存的被引用数值为2.

总结：强引用最终导致的结果就是被引用的对象的被引用次数+1;
相反的弱引用就是不会对被引用对象的被引用次数有任何影响。

二：弱引用有什么作用

防止内存泄露。

Object obj=new Object();
当你在通过异步的形式访问网络上面的资源的时候，需要的时间可能会比较长，在数据返回之前，用户很可能转向了其他的页面，
如果异步访问的对象(obj)对本地的一个对象(Object)是强引用的话，那么在这个异步访问对象(obj)被释放之前，也即在数据被回调之前，
这个被引用的对象(Object)是不会被销毁的，这样一来，就导致内存一直被占用。

WeakReference weakObj=new WeakReference(Object);
此时就可以使用弱引用，弱引用对象(weakObj)发出异步请求，
在回调之前，如果用户要转到其他的页面，这个被引用的对象(Object)是可以被释放的，这样子就不会出现内存一直被占用的现象。

三：怎样使用弱引用

弱引用类： WeakReference //有两个重载的构造函数

WeakReference WeakObj=new WeakReference(Object);//弱引用方式

IsAlive属性是判断此弱引用对象所引用的对象是否还存在，存在：IsAlive=True;
Target属性是设置该弱引用对象所引用的数据对象的值

单例模式 https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F


数据库优化
索引内部原理：
想象成Dictionary, 
插入、删除、更新的速度慢了
多占了空间
查询的速度快了

1、在经常检索的字段上使用索引
2、select中只列出必要的字段，而不是*
3、避免隐式转换造成全表扫描
   在索引上使用函数也会造成全表扫描
   （索引只是为字段建立的，一旦使用表达式或者函数，那么索引就失效了
     可以使用“函数索引”、“表达式索引”解决）
   使用索引不一定能提高查询速度
4、避免在索引列上使用计算


索引被创建于已有的表中，它可使对行的定位更快速更有效。
可以在表格的一个或者多个列上创建索引，每个索引都会被起个名字。
用户无法看到索引，它们只能被用来加速查询。

注释：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。
因此，理想的做法是仅仅在常常用于搜索的列上面创建索引。

唯一索引： CREATE UNIQUE INDEX 索引名称 ON 表名称 (列名称) 
简单索引： CREATE INDEX PersonIndex ON Person (LastName)
降序索引： CREATE INDEX PersonIndex ON Person (LastName DESC) 
多列索引： CREATE INDEX PersonIndex ON Person (LastName, FirstName)

函数索引： CREATE INDEX P_IDX ON Person (SUBSTR(COLUMN1,0,5));
当执行SELECT * FROM TABLE1 WHERE SUBSTR(COLUMN1,0,5) = XXX 时会用到索引。
但执行SELECT * FROM TABLE1 WHERE COLUMN1 = XXX时是不会用到索引的

表达式索引： CREATE INDEX P_IDX ON Person (LOWER(COLUMN1));


存储过程：
1、提高性能，减少网络传输，节约时间
2、减少网络流量
3、安全 减少sql注入式攻击
4、可维护性高

1、交互性差
2、可移植性差

get、post
get的参数会显示在浏览器地址栏中，而post的不会

使用post提交的页面在点击【刷新】按钮时，浏览器一般会提示“是否重新提交”，而get不会

用get的页面可以被搜索引擎抓取，而post的不会

用post可以提交的数据量非常大，而get的受限于网页地址的长度，只有2K

用post可以进行文件提交，而get不可以


Http: 80
Ftp: 21
Sql Server: 1433


AJAX最本质的实现是在Javascript中使用XMLHttpRequest进行Http请求。
AJAX最重要的问题是无法跨域请求。

Application 用来存取整个网站全局的信息
Session 用来存取于具体某个访问者关联的信息
























